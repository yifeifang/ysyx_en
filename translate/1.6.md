[#](#Watch-Point) Watch Point
=============

The function of watchpoints is to monitor when the value of an expression changes. If you've never used watchpoints before, try them out in GDB.

### [#](#Extending-the-functionality-of-expression-evaluation) Extending the functionality of expression evaluation

You've already implemented arithmetic expressions, but these expressions are composed of constants and their values don't change. Such expressions do not make sense in a watchpoint, so in order to utilize the watchpoint's functionality, you first need to extend the expression evaluation functionality.

We use BNF to illustrate what functionality needs to be extended:

    <expr> ::= <decimal-number>
      | <hexadecimal-number>    # Start with "0x"
      | <reg_name>              # Start with "$"
      | "(" <expr> ")"
      | <expr> "+" <expr>
      | <expr> "-" <expr>
      | <expr> "*" <expr>
      | <expr> "/" <expr>
      | <expr> "==" <expr>
      | <expr> "!=" <expr>
      | <expr> "&&" <expr>
      | "*" <expr>              # pointer dereference
    

Their function is the same as their corresponding C operators, including precedence and combinability, so if in doubt, consult the documentation.

Regarding getting the value of a register, this is obviously an ISA-related function. The framework code has prepared the following API.

    // nemu/src/isa/$ISA/reg.c
    word_t isa_reg_str2val(const char *s, bool *success);
    

It is used to return the value of the register named `s` and set `success` to indicate success.

It is also important to note that how pointer dereferences operator is parsed, and there is no way to distinguish multiplication from pointer dereferences by just looking at the operator itself, because they are both `*`. We need to distinguish them before recursively evaluating them, otherwise if we treat pointer dereferences as multiplications, the evaluation process will consider the expression to be illegal. It's not that hard to tell them apart, given an expression, you can tell them from each other. In fact, by looking at the type of the token before the `*`, we can decide whether the `*` is a multiplication or a pointer dereference, don't you think? Here's the framework for the `expr()` function.

    if (!make_token(e)) {
      *success = false;
      return 0;
    }
    
    /* TODO: Implement code to evaluate the expression. */
    
    for (i = 0; i < nr_token; i ++) {
      if (tokens[i].type == '*' && (i == 0 || tokens[i - 1].type == certain type) ) {
        tokens[i].type = DEREF;
      }
    }
    
    return eval(?, ?);
    

The `certain type` is up to you to figure out! In fact, the above framework can also handle negative numbers, so if you've implemented negative numbers before, you shouldn't have any trouble identifying `*`.

In addition, we've simplified the expressions in the simple debugger compared to the expressions in GDB, which are not type-specific, so we need to make two extra points:

* All results are of type `uint32_t`.
* Pointers also have no type, and for pointer dereferencing, we always read an integer of type `uint32_t` from the client computer's memory.

#### Extending the functionality of expression evaluation

You need to implement the functions listed in the above BNF. The above BNF does not list all the operators in C, such as the various bitwise operations, `<=`,  and etc. `==` and `&&` are likely to be used when using watchpoints, so you are required to implement them. If in the future you find it inconvenient to use a particular operator because it is missing, you can consider implementing it then.

#### Expression evaluation in riscv64

Since riscv64 is a 64-bit ISA, you need to interpret the result of the expression as a `uint64_t` type.

#### Limitation of testing

We have previously implemented an expression generator, but after adding register usage and pointer dereferencing to expression evaluation, the expression generator does not meet all of our needs. This is because the semantics of registers do not exist in C programs, and the semantics of pointer dereferencing are very different from NEMU.

The point here is that testing has its limitations, and no single technique can solve all problems all at once. This is especially true of cutting-edge research: they often solve only a small part of the problem. However, this expression generator gives you a lot of confidence that there is value in thinking about how to easily test your code, even if it is only partially tested.

### [#](#implement-watchpoints) implement watchpoints

The simple debugger allows the user to set multiple watchpoints and delete watchpoints, so it is better to organize the information of watchpoints in a linked list. The structure of the watchpoint is already defined in the framework code (in `nemu/src/monitor/sdb/watchpoint.c`).

    typedef struct watchpoint {
      int NO;
      struct watchpoint *next;
    
      /* TODO: Add more members if necessary */
    
    } WP;
    
However, there are only two members defined in the structure: `NO` for the watchpoint's ID, and there is no need to explain `next` . In order to implement the watchpoint feature, you need to add the necessary members to the structure according to your understanding of how watchpoints work. We also use a "pool" data structure to manage the watchpoint object, a part of which is given in the framework code.

    static WP wp_pool[NR_WP] = {};
    static WP *head = NULL, *free_ = NULL;
    

The code defines a watchpoint pool, `wp_pool`, and two linked lists, `head` and `free_`, where `head` is used to organize watchpoints in use and `free_` is used to organize free watchpoints, and the `init_wp_pool()` function will initialize the two linked lists.

#### Implement watchpoint pool management logic

In order to use the watchpoint pool, you need to write the following two functions (you can modify the parameters and return values of the functions according to your needs).

    WP* new_wp();
    void free_wp(WP *wp);
    

The functions `new_wp()` return a free watchpoint object from the `free_` list, and `free_wp()` puts `wp` back into the `free_` list, these two functions will be used as the interface to the watchpoint pool by other functions. Note that when calling `new_wp()` there may be no free watchpoint structure, for simplicity you can terminate the program immediately with `assert(0)`. The framework code defines 32 watchpoint objects, which should be enough for general use. If you need more, you can change the value of the `NR_WP` macro.

These two functions need to perform some linked list insertion and deletion operations, for students who are not familiar with the operation of the linked list, this can be used as an exercise for the linked list.

#### Recall the past to understand the future

The framework code uses the keyword `static` when defining variables such as `wp_pool`, what does `static` mean in this context? Why is it used here?

Once you have implemented the management logic of the watchpoint pool, you can think about how to implement the watchpoint feature. Specifically, you need to implement the following functionality.

* When the user gives an expression to be watched, you need to request a free watchpoint structure via `new_wp()` and record the expression. All watchpoints are then checked in a loop at the end of the `trace_and_difftest()` function (defined in `nemu/src/cpu/cpu-exec.c`), which is called every time the `cpu_exec()` loop finishes executing an instruction. During the check of the watchpoints, you need to evaluate the corresponding expressions of the watchpoints (you have already implemented the expression evaluation function) and compare their values to see if they have changed, if they have changed, the program will pause due to the triggering of the watchpoints. You need to set the `nemu_state.state` variable to `NEMU_STOP` to pause the execution. Finally, you output a message that the user has triggered a watchpoint, and return to the `sdb_mainloop()` loop to wait for the user's command.
* Use the `info w` command to print information about the watchpoints in use. You can refer to the `info watchpoints` results in GDB for more information on what to print.
* Use the `d` command to delete watchpoints, you just need to free the corresponding watchpoint object.

#### Implement watchpoint

You need to implement the watchpoint-related functionality described above, and once you have implemented expression evaluation, the focus of the watchpoint implementation is on linked-list operations.

Since watchpoints need to be checked in every loop of `cpu_exec()`, this can be a significant performance overhead for the NEMU. We can put the watchpoint checking in `trace_and_difftest()` and wrap the watchpoint checking code in a new macro `CONFIG_WATCHPOINT`; then we can add a switch to watchpoints in `nemu/Kconfig`, and then turn on the switch via menuconfig to activate the watchpoints. When you don't need to use the watchpoint, you can turn off the switch in menuconfig to improve the performance of NEMU.

It is also possible to trigger more than two watchpoints at the same time, you are free to decide how to handle these special cases, we don't have a hard rule about this.

[#](#Debugging-Tools-and-Principles) Debugging Tools and Principles
---------------------

在实现监视点的过程中, 你很有可能会碰到段错误. 如果你因此而感觉到无助, 你应该好好阅读这一小节的内容.

我们来简单梳理一下段错误发生的原因. 首先, 机器永远是对的. 如果程序出了错, 先怀疑自己的代码有bug. 比如由于你的疏忽, 你编写了`if (p = NULL)`这样的代码. 但执行到这行代码的时候, 也只是`p`被赋值成`NULL`, 程序还会往下执行. 然而等到将来对`p`进行了解引用的时候, 才会触发段错误, 程序彻底崩溃.

我们可以从上面的这个例子中抽象出一些软件工程相关的概念:

*   Fault: 实现错误的代码, 例如`if (p = NULL)`
*   Error: 程序执行时不符合预期的状态, 例如`p`被错误地赋值成`NULL`
*   Failure: 能直接观测到的错误, 例如程序触发了段错误

调试其实就是从观测到的failure一步一步回溯寻找fault的过程, 找到了fault之后, 我们就很快知道应该如何修改错误的代码了. 但从上面的例子也可以看出, 调试之所以不容易, 恰恰是因为:

*   fault不一定马上触发error
*   触发了error也不一定马上转变成可观测的failure
*   error会像滚雪球一般越积越多, 当我们观测到failure的时候, 其实已经距离fault非常遥远了

理解了这些原因之后, 我们就可以制定相应的策略了:

*   尽可能把fault转变成error. 这其实就是测试做的事情, 所以我们在上一节中加入了表达式生成器的内容, 来帮助大家进行测试, 后面的实验内容也会提供丰富的测试用例. 但并不是有了测试用例就能把所有fault都转变成error了, 因为这取决于测试的覆盖度. 要设计出一套全覆盖的测试并不是一件简单的事情, 越是复杂的系统, 全覆盖的测试就越难设计. 但是, 如何提高测试的覆盖度, 是学术界一直以来都在关注的问题.

#### 你会如何测试你的监视点实现?

我们没有提供监视点相关的测试, 思考一下, 你会如何测试?

当然, 对于实验来说, 将来边用边测也是一种说得过去的方法, 就看你对自己代码的信心了.

*   尽早观测到error的存在. 观测到error的时机直接决定了调试的难度: 如果等到触发failure的时候才发现error的存在, 调试就会比较困难; 但如果能在error刚刚触发的时候就观测到它, 调试难度也就大大降低了. 事实上, 你已经见识过一些有用的工具了:
    *   `-Wall`, `-Werror`: 在编译时刻把潜在的fault直接转变成failure. 这种工具的作用很有限, 只能寻找一些在编译时刻也觉得可疑的fault, 例如`if (p = NULL)`. 不过随着编译器版本的增强, 编译器也能发现代码中的一些[未定义行为open in new window](https://en.wikipedia.org/wiki/Undefined_behavior). 这些都是免费的午餐, 不吃就真的白白浪费了.
    *   `assert()`: 在运行时刻把error直接转变成failure. `assert()`是一个很简单却又非常强大的工具, 只要在代码中定义好程序应该满足的特征, 就一定能在运行时刻将不满足这些特征的error拦截下来. 例如链表的实现, 我们只需要在代码中插入一些很简单的`assert()`(例如指针解引用时不为空), 就能够几乎告别段错误. 但是, 编写这些`assert()`其实需要我们对程序的行为有一定的了解, 同时在程序特征不易表达的时候, `assert()`的作用也较为有限.
    *   `printf()`: 通过输出的方式观察潜在的error. 这是用于回溯fault时最常用的工具, 用于观测程序中的变量是否进入了错误的状态. 在NEMU中我们提供了输出更多调试信息的宏`Log()`, 它实际上封装了`printf()`的功能. 但由于`printf()`需要根据输出的结果人工判断是否正确, 在便利程度上相对于`assert()`的自动判断就逊色了不少.
    *   GDB: 随时随地观测程序的任何状态. 调试器是最强大的工具, 但你需要在程序行为的茫茫大海中观测那些可疑的状态, 因此使用起来的代价也是最大的.

#### 强大的GDB

如果你遇到了段错误, 你很可能会想知道究竟是哪一行代码触发了段错误. 尝试编写一个触发段错误的程序, 然后在GDB中运行它. 你发现GDB能为你提供哪些有用的信息吗?

#### sanitizer - 一种底层的assert

段错误一般是由于非法访存造成的, 一种简单的想法是, 如果我们能在每一次访存之前都用`assert()`检查一下地址是否越界, 就可以在段错误发生之前捕捉到error了!

虽然我们只需要重点关注指针和数组的访问, 但这样的代码在项目中有很多, 如果要我们手动在这些访问之前添加`assert()`, 就太麻烦了. 事实上, 最适合做这件事情的是编译器, 因为它能知道指针和数组的访问都在哪里. 而让编译器支持这个功能的是一个叫`Address Sanitizer`的工具, 它可以自动地在指针和数组的访问之前插入用来检查是否越界的代码. GCC提供了一个`-fsanitize=address`的编译选项来启用它. menuconfig已经为大家准备好相应选项了, 你只需要打开它:

    Build Options
      [*] Enable address sanitizer
    

然后清除编译结果并重新编译即可.

你可以尝试故意触发一个段错误, 然后阅读一下Address Sanitizer的报错信息. 不过你可能会发现程序的性能有所下降, 这是因为对每一次访存进行检查会带来额外的性能开销. 但作为一个可以帮助你诊断bug的工具, 付出这一点代价还是很值得的, 而且你还是可以在无需调试的时候将其关闭.

事实上, 除了地址越界的错误之外, Address Sanitizer还能检查use-after-free的错误 (即"释放从堆区申请的空间后仍然继续使用"的错误), 你知道它是如何实现这一功能的吗?

#### 更多的sanitizer

事实上, GCC还支持更多的sanitizer, 它们可以检查各种不同的错误, 你可以在`man gcc`中查阅`-fsanitize`相关的选项. 如果你的程序在各种sanitizer开启的情况下仍然能正确工作, 就说明你的程序还是有一定质量的.

根据上面的分析, 我们就可以总结出一些调试的建议:

*   总是使用`-Wall`和`-Werror`
*   尽可能多地在代码中插入`assert()`
*   调试时先启用sanitizer
*   `assert()`无法捕捉到error时, 通过`printf()`输出可疑的变量, 期望能观测到error
*   `printf()`不易观测error时, 通过GDB理解程序的精确行为

如果你在程序设计课上听说过上述这些建议, 相信你几乎不会遇到运行时错误.

[#](#断点) 断点
-----------

断点的功能是让程序暂停下来, 从而方便查看程序某一时刻的状态. 事实上, 我们可以很容易地用监视点来模拟断点的功能:

    w $pc == ADDR
    

其中`ADDR`为设置断点的地址. 这样程序执行到`ADDR`的位置时就会暂停下来.

#### 如何提高断点的效率 (建议二周目思考)

如果你在运行稍大一些的程序(如microbench)的时候使用断点, 你会发现设置断点之后会明显地降低NEMU执行程序的效率. 思考一下这是为什么? 有什么方法解决这个问题吗?

调试器设置断点的工作方式和上述通过监视点来模拟断点的方法大相径庭. 事实上, 断点的工作原理, 竟然是三十六计之中的"偷龙转凤"! 如果你想揭开这一神秘的面纱, 你可以阅读[这篇文章open in new window](http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints). 了解断点的工作原理之后, 可以尝试思考下面的两个问题.

#### 一点也不能长?

x86的`int3`指令不带任何操作数, 操作码为1个字节, 因此指令的长度是1个字节. 这是必须的吗? 假设有一种x86体系结构的变种my-x86, 除了`int3`指令的长度变成了2个字节之外, 其余指令和x86相同. 在my-x86中, 上述文章中的断点机制还可以正常工作吗? 为什么?

#### 随心所欲的断点

如果把断点设置在指令的非首字节(中间或末尾), 会发生什么? 你可以在GDB中尝试一下, 然后思考并解释其中的缘由.

#### NEMU的前世今生

你已经对NEMU的工作方式有所了解了. 事实上在NEMU诞生之前, NEMU曾经有一段时间并不叫NEMU, 而是叫NDB(NJU Debugger), 后来由于某种原因才改名为NEMU. 如果你想知道这一段史前的秘密, 你首先需要了解这样一个问题: 模拟器(Emulator)和调试器(Debugger)有什么不同? 更具体地, 和NEMU相比, GDB到底是如何调试程序的?

[表达式求值](/docs/ics-pa/1.5.html) [如何阅读手册](/docs/ics-pa/1.7.html)
